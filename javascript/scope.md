---
description: '목표: 스코프와 클로저의 개념을 알아보고 이와 관련된 내용 및 코드 예제들을 살펴봅니다.'
---

# 스코프와 클로저

프로그래밍 언어에서는 어떤 값을 기억하기 위해 변수라는 공간에 값을 저장합니다. 변수는 어딘가에 존재하여 프로그램으로부터 참조 가능한 주소값입니다. 변수를 참조하면 거기에 담긴 값을 끄집어 가져오는 것 뿐입니다.

변수가 어딘가에 존재한다고 했는데, 만약 모든 변수가 하나의 공간에 존재한다고 하면 어떤 문제가 발생할까요? 아마 변수가 많아질수록 동일한 변수 명이 겹쳐서 충돌하는 문제가 발생할 확률이 높아질 것입니다.

{% file src="../.gitbook/assets/scope-figure-1.jpeg" %}

그래서 많은 프로그래밍 언어들은 변수 명이 동일하더라도 이를 별개의 참조 가능한 영역으로 구분할 수 있도록 만들었는데요, 이렇게 변수가 참조 가능하도록 만드는 규칙을 **스코프\(scope\) 혹은 유효범위**라고 합니다.

## 중첩 스코프

중첩 스코프\(Nested Scope\)는 스코프가 다른 스코프의 안에 포함되는 형식을 말합니다.

어떤 변수를 호출했을 때, 현재 스코프에서 찾지 못한다면 상위 스코프에서 찾고, 거기서도 찾지 못한다면 그 다음 상위 스코프에서 찾을 것입니다. 이는 **글로벌 스코프**라고 불리는 가장 바깥에 존재하는 스코프에 도달할 때 까지 계속될 것입니다.

```javascript
function foo(a) {
  console.log(a + b);
}

var b = 2;

foo(2); // 4
```

위의 코드를 살펴보면 아래와 같은 동작으로 이뤄질 것입니다.

1. foo 스코프 내부에서 a 변수 참조 : 성공
2. foo 스코프 내부에서 b 변수 참조 : 실패
3. 글로벌 스코프에서 b 변수 참조 : 성공
4. a + b 반환

## 렉시컬 스코프

렉시컬 스코프\(Lexical scope\)는 자바스크립트에서 채용한 스코프 규칙이며 대다수의 프로그래밍 언어에서 채택한 방식입니다.

### 렉스타임

### 섀도잉

## 함수 vs 블록 스코프

## 호이스팅

호이스팅\(Hoising\)은 사전적 의미로 '끌어올리다' 정도의 뜻입니다. 자바스크립트에서 말 그대로 특정 변수를 **스코프의 최상단**으로 끌어올리는듯한 동작을 말합니다.

```javascript
catName("Chloe");

function catName(name) {
  console.log("My cat's name is " + name);
}
// "My cat's name is Chloe"
```

위 코드를 보면, 함수의 선언문이 있기 전에 해당 함수를 수행했는데 불구하고 마치 함수 선언문을 위로 끌어올린 것 처럼 정상적으로 동작하는 것을 볼 수 있습니다.

### JIT 컴파일

자바스크립트 코드가 실행되는 과정에서 인터프리트 되기 이전에 JIT\(Just In Time\) 컴파일 과정을 거치게 됩니다.

## 클로저

### 즉시 실행 함수\(IIFE\)

### 모듈 패턴

